#!/usr/bin/python

#if __name__ == '__main__' and __package__ is None:
#    from os import sys, path
#    sys.path.append(path.dirname(path.dirname(path.abspath(__file__))))

import sys
import os
cur_dir = os.path.dirname(__file__)
if not cur_dir in sys.path:
    sys.path.append(cur_dir)

import web
import locals
import datetime
import json
import re

from config import es_constants
from database import querydb
from database import crud

from apps.acquisition import get_eumetcast
from apps.productmanagement.datasets import Dataset


def row2dict(row):
    d = {}
    for column in row.c._all_cols:
        d[column.name] = str(getattr(row, column.name))

    return d


def tojson(queryresult):
    jsonresult = ''
    for row in queryresult:
        da = row2dict(row)
        jsonresult = jsonresult + json.dumps(da,
                                             ensure_ascii=False,
                                             sort_keys=True,
                                             indent=4,
                                             separators=(',', ': ')) + ', '
    jsonresult = jsonresult[:-2]
    return jsonresult


# Return True if the date is in the correct format
def checkDateFormat(myString):
    isDate = re.match('[0-1][0-9]\/[0-3][0-9]\/[1-2][0-9]{3}', myString)
    return isDate


import urllib2

def internet_on():
    try:
        response = urllib2.urlopen('http://74.125.228.100', timeout=1)
        return True
    except urllib2.URLError as err: pass
    return False


import socket
REMOTE_SERVER = "www.google.com"
def is_connected():
  try:
    # see if we can resolve the host name -- tells us if there is
    # a DNS listening
    host = socket.gethostbyname(REMOTE_SERVER)
    # connect to the host -- tells us if the host is actually
    # reachable
    s = socket.create_connection((host, 80), 2)
    return True
  except:
     pass
  return False
print is_connected()



WEBPY_COOKIE_NAME = "webpy_session_id"

urls = (
    "/pa(.*)", "ProductAcquisition",
    "/product/update", "UpdateProduct",

    "/services/checkstatusall", "CheckStatusAllServices",
    "/services/execservicetask", "ExecuteServiceTask",

    "/ingestion", "Ingestion",
    "/ingestion/update", "UpdateIngestion",

    "/dataacquisition", "DataAcquisition",
    "/dataacquisition/update", "UpdateDataAcquisition",

    "/datasets", "DataSets",

    "/template", "TemplatePage",
    #"/(.+)/(.+)", "EsApp",
    #"/(.+)/", "EsApp",
    "/", "EsApp")

app = web.application(urls, globals(), autoreload=True)
application = app.wsgifunc()
#session = web.session.Session(app, web.session.DiskStore('../logs/mstmp/webpySessions'))


class EsApp:
    def __init__(self):
        self.lang = "en"

    def GET(self):
        #return sys.path
        #return web.ctx
        render = web.template.render(locals.es2globals['base_dir']+'/apps/gui/esapp')
        return render.index()
        #getparam = web.input(lang=self.lang)
        #return render.index(getparam.lang)


class DataSets:
    def __init__(self):
        self.lang = "en"

    def GET(self):
        #return web.ctx
        datasets = {"success": "true",
                    "products": [{
                        "activated": "True",
                        "cat_descr_name": "Vegetation",
                        "category_id": "vegetation",
                        "defined_by": "JRC",
                        "description": "The FAPAR is the Fraction of Absorbed Photosynthetically Active radiation. The FAPAR quantifies the fraction of the solar radiation absorbed by live leaves for the photosynthesis activity. Then, it refers only to the green and alive elements of the canopy. The FAPAR depends on the canopy structure, vegetation element optical properties, atmospheric conditions, and angular configuration. To overcome this latter dependency, a daily integrated FAPAR value is assessed. \r\nFAPAR is recognized as an Essential Climate Variable (ECV) by the Global Climate Observing System (GCOS).",
                        "order_index": "1",
                        "prod_descriptive_name": "FAPAR",
                        "productID": "vgt_fapar_V1.3",
                        "product_type": "Native",
                        "productcode": "vgt_fapar",
                        "subproductcode": "vgt_fapar_native",
                        "version": "V1.3",

                        "productmapsets": [{
                            "mapsetcode": "WGS84_ECOWAS_1km",
                            "defined_by": "JRC",
                            "descriptive_name": "ECOWAS 1km",
                            "description": "WGS84_ECOWAS_1km",
                            "srs_wkt": 'GEOGCS["WGS 84",DATUM["WGS_1984",SPHEROID["WGS 84",6378137,298.257223563,AUTHORITY["EPSG","7030"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY["EPSG","6326"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9108"]],AUTHORITY["EPSG","4326"]]',
                            "upper_left_long": -19.0044642857143,
                            "pixel_shift_long": 0.008928571428571,
                            "rotation_factor_long": 0,
                            "upper_left_lat": 28.0044642857143,
                            "pixel_shift_lat": -0.008928571428571,
                            "rotation_factor_lat": 0,
                            "pixel_size_x": 4929,
                            "pixel_size_y": 2689,
                            "footprint_image": "",

                            "mapsetdatasets": [{
                                "datasetID": "vgt_fapar_V1.3_fapar",
                                "product_type": "Ingest",
                                "productcode": "vgt_fapar",
                                "subproductcode": "fapar",
                                "version": "V1.3",
                                "activated": "True",
                                "defined_by": "JRC",
                                "description": "",
                                "prod_descriptive_name": "",

                                "datasetcompleteness": {
                                    "firstdate": "2013-07-01",
                                    "datasetintervals": [
                                        {
                                            "fromdate": "2013-07-01",
                                            "intervalpercentage": 2.127659574468085,
                                            "intervaltype": "present",
                                            "missing": "false",
                                            "todate": "2013-07-01",
                                            "totfiles": 1
                                        },
                                        {
                                            "fromdate": "2013-07-11",
                                            "intervalpercentage": 97.87234042553192,
                                            "intervaltype": "missing",
                                            "missing": "true",
                                            "todate": "2014-10-11",
                                            "totfiles": 46
                                        }
                                    ],
                                    "lastdate": "2014-10-11",
                                    "missingfiles": 46,
                                    "totfiles": 47
                                },
                            }]
                        }]
                    }, {
                        "activated": "True",
                        "cat_descr_name": "Vegetation",
                        "category_id": "vegetation",
                        "defined_by": "JRC",
                        "description": "The NDVI can be used to measure and monitor plant growth, vegetation cover, and biomass production. It is a dimensionless variable.  The values vary between -1 and 1. Increasing positive NDVI values indicate increasing amounts of green vegetation. Moderate values represent shrub and grassland (0.2 to 0.3), while high values indicate temperate and tropical rainforests (0.6 to 0.8). NDVI values near zero and decreasing negative values indicate non-vegetated features such as barren surfaces (rock and soil) and water, snow, ice, and clouds.",
                        "order_index": "1",
                        "prod_descriptive_name": "Normalized Difference Vegetation Index",
                        "productID": "vgt_ndvi_undefined",
                        "product_type": "Native",
                        "productcode": "vgt_ndvi",
                        "subproductcode": "vgt_ndvi_native",
                        "version": "undefined",

                        "productmapsets": [{
                            "mapsetcode": "WGS84_ECOWAS_1km",
                            "defined_by": "JRC",
                            "descriptive_name": "ECOWAS 1km",
                            "description": "WGS84_ECOWAS_1km",
                            "srs_wkt": 'GEOGCS["WGS 84",DATUM["WGS_1984",SPHEROID["WGS 84",6378137,298.257223563,AUTHORITY["EPSG","7030"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY["EPSG","6326"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9108"]],AUTHORITY["EPSG","4326"]]',
                            "upper_left_long": -19.0044642857143,
                            "pixel_shift_long": 0.008928571428571,
                            "rotation_factor_long": 0,
                            "upper_left_lat": 28.0044642857143,
                            "pixel_shift_lat": -0.008928571428571,
                            "rotation_factor_lat": 0,
                            "pixel_size_x": 4929,
                            "pixel_size_y": 2689,
                            "footprint_image": "",

                            "mapsetdatasets": [{
                                "datasetID": "vgt_ndvi_undefined_ndv",
                                "product_type": "Ingest",
                                "productcode": "vgt_ndvi",
                                "subproductcode": "ndv",
                                "version": "undefined",
                                "activated": "True",
                                "defined_by": "JRC",
                                "description": "The NDVI can be used to measure and monitor plant growth, vegetation cover, and biomass production. It is a dimensionless variable.  The values vary between -1 and 1. Increasing positive NDVI values indicate increasing amounts of green vegetation. Moderate values represent shrub and grassland (0.2 to 0.3), while high values indicate temperate and tropical rainforests (0.6 to 0.8). NDVI values near zero and decreasing negative values indicate non-vegetated features such as barren surfaces (rock and soil) and water, snow, ice, and clouds.",
                                "prod_descriptive_name": "Normalized Difference Vegetation Index",

                                "datasetcompleteness": {
                                    "firstdate": "2013-07-01",
                                    "datasetintervals": [
                                        {
                                            "fromdate": "2013-07-01",
                                            "intervalpercentage": 2.127659574468085,
                                            "intervaltype": "present",
                                            "missing": "false",
                                            "todate": "2013-07-01",
                                            "totfiles": 1
                                        },
                                        {
                                            "fromdate": "2013-07-11",
                                            "intervalpercentage": 97.87234042553192,
                                            "intervaltype": "missing",
                                            "missing": "true",
                                            "todate": "2014-10-11",
                                            "totfiles": 46
                                        }
                                    ],
                                    "lastdate": "2014-10-11",
                                    "missingfiles": 46,
                                    "totfiles": 47
                                },
                            }, {
                                "datasetID": "vgt_ndvi_undefined_sm",
                                "product_type": "Ingest",
                                "productcode": "vgt_ndvi",
                                "subproductcode": "sm",
                                "version": "undefined",
                                "activated": "True",
                                "defined_by": "JRC",
                                "description": "Status map of the NDVI.",
                                "prod_descriptive_name": "Status map",

                                "datasetcompleteness": {
                                    "firstdate": "2013-07-01",
                                    "datasetintervals": [
                                        {
                                            "fromdate": "2013-07-01",
                                            "intervalpercentage": 2.127659574468085,
                                            "intervaltype": "present",
                                            "missing": "false",
                                            "todate": "2013-07-01",
                                            "totfiles": 1
                                        },
                                        {
                                            "fromdate": "2013-07-11",
                                            "intervalpercentage": 97.87234042553192,
                                            "intervaltype": "missing",
                                            "missing": "true",
                                            "todate": "2014-10-11",
                                            "totfiles": 46
                                        }
                                    ],
                                    "lastdate": "2014-10-11",
                                    "missingfiles": 46,
                                    "totfiles": 47
                                },
                            }]
                        }, {
                            "mapsetcode": "WGS84_Africa_1km",
                            "defined_by": "JRC",
                            "descriptive_name": "Africa 1km",
                            "description": "Original Spot VGT 1km mapset",
                            "srs_wkt": 'GEOGCS["WGS 84",DATUM["WGS_1984",SPHEROID["WGS 84",6378137,298.257223563,AUTHORITY["EPSG","7030"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY["EPSG","6326"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9108"]],AUTHORITY["EPSG","4326"]]',
                            "upper_left_long": -26.0044642857143,
                            "pixel_shift_long": 0.008928571428571,
                            "rotation_factor_long": 0,
                            "upper_left_lat": 38.0044642857143,
                            "pixel_shift_lat": -0.008928571428571,
                            "rotation_factor_lat": 0,
                            "pixel_size_x": 9633,
                            "pixel_size_y": 8177,
                            "footprint_image": "",

                            "mapsetdatasets": [{
                                "datasetID": "vgt_ndvi_undefined_ndv",
                                "product_type": "Ingest",
                                "productcode": "vgt_ndvi",
                                "subproductcode": "ndv",
                                "version": "undefined",
                                "activated": "True",
                                "defined_by": "JRC",
                                "description": "The NDVI can be used to measure and monitor plant growth, vegetation cover, and biomass production. It is a dimensionless variable.  The values vary between -1 and 1. Increasing positive NDVI values indicate increasing amounts of green vegetation. Moderate values represent shrub and grassland (0.2 to 0.3), while high values indicate temperate and tropical rainforests (0.6 to 0.8). NDVI values near zero and decreasing negative values indicate non-vegetated features such as barren surfaces (rock and soil) and water, snow, ice, and clouds.",
                                "prod_descriptive_name": "Normalized Difference Vegetation Index",

                                "datasetcompleteness": {
                                    "firstdate": "2013-07-01",
                                    "datasetintervals": [
                                        {
                                            "fromdate": "2013-07-01",
                                            "intervalpercentage": 2.127659574468085,
                                            "intervaltype": "present",
                                            "missing": "false",
                                            "todate": "2013-07-01",
                                            "totfiles": 1
                                        },
                                        {
                                            "fromdate": "2013-07-11",
                                            "intervalpercentage": 97.87234042553192,
                                            "intervaltype": "missing",
                                            "missing": "true",
                                            "todate": "2014-10-11",
                                            "totfiles": 46
                                        }
                                    ],
                                    "lastdate": "2014-10-11",
                                    "missingfiles": 46,
                                    "totfiles": 47
                                },
                            }, {
                                "datasetID": "vgt_ndvi_undefined_sm",
                                "product_type": "Ingest",
                                "productcode": "vgt_ndvi",
                                "subproductcode": "sm",
                                "version": "undefined",
                                "activated": "True",
                                "defined_by": "JRC",
                                "description": "Status map of the NDVI.",
                                "prod_descriptive_name": "Status map",

                                "datasetcompleteness": {
                                    "firstdate": "2013-07-01",
                                    "datasetintervals": [
                                        {
                                            "fromdate": "2013-07-01",
                                            "intervalpercentage": 2.127659574468085,
                                            "intervaltype": "present",
                                            "missing": "false",
                                            "todate": "2013-07-01",
                                            "totfiles": 1
                                        },
                                        {
                                            "fromdate": "2013-07-11",
                                            "intervalpercentage": 97.87234042553192,
                                            "intervaltype": "missing",
                                            "missing": "true",
                                            "todate": "2014-10-11",
                                            "totfiles": 46
                                        }
                                    ],
                                    "lastdate": "2014-10-11",
                                    "missingfiles": 46,
                                    "totfiles": 47
                                },
                            }]
                        }]
                    }]}

        return datasets


class CheckStatusAllServices:
    def __init__(self):
        self.lang = "en"

    def POST(self):
        #return web.ctx
        eumetcast = "true"
        internet = "false"
        ingest = "true"
        servicesstatus_json = '{"success": true, "eumetcast": ' + eumetcast + \
                              ', "internet": ' + internet + \
                              ', "ingest": ' + ingest + '}'
        return servicesstatus_json


class ExecuteServiceTask:
    def __init__(self):
        self.lang = "en"

    def POST(self):
        #return web.ctx
        getparams = web.input()
        if getparams.task == 'runinternet':
            # if internet_on() run getinternet service
            print 'run internet'
        if getparams.task == 'stopinternet':
            # if internet_on() run getinternet service
            print 'stop internet'
        if getparams.task == 'restartinternet':
            # if internet_on() run getinternet service
            print 'restart internet'

        servicesstatus_json = '{"success": true, "task": "' + getparams.task + '"}'
        return servicesstatus_json


class UpdateProduct:
    def __init__(self):
        self.lang = "en"
        self.crud_db = crud.CrudDB(schema=es_constants.dbglobals['schema_products'])

    def PUT(self):
        #return web.ctx
        getparams = json.loads(web.data())
        productinfo = {'productcode': getparams['products']['productcode'],
                       'subproductcode': getparams['products']['subproductcode'],
                       'version': getparams['products']['version'],
                       'product_type': getparams['products']['product_type'],
                       'defined_by': getparams['products']['defined_by'],
                       'activated': getparams['products']['activated']}
        #print productinfo
        if self.crud_db.update('product', productinfo):
            updatestatus = '{"success":true, "message":"Product updated!"}'
        else:
            updatestatus = '{"success":false, "message":"An error occured while updating the product!"}'

        return updatestatus


class UpdateDataAcquisition:
    def __init__(self):
        self.lang = "en"
        self.crud_db = crud.CrudDB(schema=es_constants.dbglobals['schema_products'])

    def PUT(self):
        #return web.ctx
        getparams = json.loads(web.data())
        dataacquisitioninfo = {'productcode': getparams['dataacquisitions']['productcode'],
                               'subproductcode': getparams['dataacquisitions']['subproductcode'],
                               'version': getparams['dataacquisitions']['version'],
                               'data_source_id': getparams['dataacquisitions']['data_source_id'],
                               'defined_by': getparams['dataacquisitions']['defined_by'],
                               'activated': getparams['dataacquisitions']['activated']}
        print dataacquisitioninfo
        if self.crud_db.update('product_acquisition_data_source', dataacquisitioninfo):
            updatestatus = '{"success":true, "message":"Data source updated!"}'
        else:
            updatestatus = '{"success":false, "message":"An error occured while updating the data source!"}'

        return updatestatus


class UpdateIngestion:
    def __init__(self):
        self.lang = "en"
        self.crud_db = crud.CrudDB(schema=es_constants.dbglobals['schema_products'])

    def PUT(self):
        #return web.ctx
        getparams = json.loads(web.data())
        ingestioninfo = {'productcode': getparams['ingestions']['productcode'],
                         'subproductcode': getparams['ingestions']['subproductcode'],
                         'version': getparams['ingestions']['version'],
                         'mapsetcode': getparams['ingestions']['mapsetcode'],
                         'defined_by': getparams['ingestions']['defined_by'],
                         'activated': getparams['ingestions']['activated']}
        print ingestioninfo
        if self.crud_db.update('ingestion', ingestioninfo):
            updatestatus = '{"success":true, "message":"Ingestion updated!"}'
        else:
            updatestatus = '{"success":false, "message":"An error occured while updating the Ingestion!"}'

        return updatestatus


class Ingestion:
    def __init__(self):
        self.lang = "en"

    def GET(self):
        #return web.ctx
        ingestions = querydb.get_ingestions(echo=False)

        if ingestions.__len__() > 0:
            ingest_dict_all = []
            for row in ingestions:
                kwargs = {'product_code': row.productcode,
                          'sub_product_code': row.subproductcode,
                          'version': row.version,
                          'mapset': row.mapsetcode}
                #kwargs.update({'to_date': datetime.date(2013, 12, 31)})
                dataset = Dataset(**kwargs)
                completeness = dataset.get_dataset_normalized_info()
                ingest_dict = row2dict(row)
                ingest_dict['completeness'] = completeness
                ingest_dict_all.append(ingest_dict)

            #ingestions_json = tojson(ingestions)
            ingestions_json = json.dumps(ingest_dict_all,
                                         ensure_ascii=False,
                                         sort_keys=True,
                                         indent=4,
                                         separators=(', ', ': '))
            ingestions_json = '{"success":true, "total":'+str(ingestions.__len__())+',"ingestions":'+ingestions_json+'}'
        else:
            ingestions_json = '{"success":false, "error":"No ingestions defined!"}'

        return ingestions_json


class DataAcquisition:
    def __init__(self):
        self.lang = "en"

    def GET(self):
        #return web.ctx

        dataacquisitions = querydb.get_dataacquisitions(echo=False)

        if dataacquisitions.__len__() > 0:
            #dataacquisitions_json = tojson(dataacquisitions)

            acq_dict_all = []
            for row in dataacquisitions:
                acq_dict = row2dict(row)
                # Retrieve datetime of latest acquired file and lastest datetime
                # the acquisition was active of a specific eumetcast id
                acq_dates = get_eumetcast.get_eumetcast_info(row.data_source_id)
                if acq_dates:
                    for key in acq_dates.keys():
                        #acq_info += '"%s": "%s", ' % (key, acq_dates[key])
                        if isinstance(acq_dates[key], datetime.date):
                            datetostring = acq_dates[key].strftime("%y-%m-%d %H:%M")
                            acq_dict[key] = datetostring
                        else:
                            acq_dict[key] = acq_dates[key]
                else:
                    acq_dict['time_latest_copy'] = datetime.datetime.now().strftime("%y-%m-%d %H:%M")
                    acq_dict['time_latest_exec'] = datetime.datetime.now().strftime("%y-%m-%d %H:%M")
                    acq_dict['lenght_proc_list'] = datetime.datetime.now().strftime("%y-%m-%d %H:%M")

                acq_dict_all.append(acq_dict)
                acq_json = json.dumps(acq_dict_all,
                                      ensure_ascii=False,
                                      sort_keys=True,
                                      indent=4,
                                      separators=(', ', ': '))
                dataacquisitions_json = '{"success":true, "total":'\
                                        + str(dataacquisitions.__len__())\
                                        + ',"dataacquisitions":'+acq_json+'}'
        else:
            dataacquisitions_json = '{"success":false, "error":"No data acquisitions defined!"}'

        return dataacquisitions_json


class ProductAcquisition:
    def __init__(self):
        self.lang = "en"

    def GET(self, params):
        #return web.ctx
        getparams = web.input()
        products = querydb.get_products(echo=False, activated=getparams.activated)
        products_json = tojson(products)
        products_json = '{"success":true, "total":'+str(products.__len__())+',"products":['+products_json+']}'
        return products_json


class TemplatePage:
    def __init__(self):
        self.render = web.template.render(locals.es2globals['base_dir']+'/templates/')

    def GET(self):
        getInput=web.input(name="World")
        return self.render.mytemplate("mytitle", getInput.name)

if __name__ == "__main__":
    app.run()