#!/usr/bin/python

#if __name__ == '__main__' and __package__ is None:
#    from os import sys, path
#    sys.path.append(path.dirname(path.dirname(path.abspath(__file__))))

import sys
import os
cur_dir = os.path.dirname(__file__)
if not cur_dir in sys.path:
    sys.path.append(cur_dir)

import web
import locals
import datetime
import json
import re

from config import es_constants
from database import querydb
from database import crud

from apps.acquisition import get_eumetcast
from apps.acquisition import acquisition
from apps.productmanagement.datasets import Dataset
from apps.productmanagement.products import Product
from apps.analysis import mapserver

from lib.python import functions
from lib.python import es_logging as log

logger = log.my_logger(__name__)


WEBPY_COOKIE_NAME = "webpy_session_id"

urls = (
    "/pa(.*)", "ProductAcquisition",
    "/product/update", "UpdateProduct",

    "/services/checkstatusall", "CheckStatusAllServices",
    "/services/execservicetask", "ExecuteServiceTask",

    "/ingestion", "Ingestion",
    "/ingestion/update", "UpdateIngestion",

    "/dataacquisition", "DataAcquisition",
    "/dataacquisition/update", "UpdateDataAcquisition",

    "/datasets", "DataSets",

    "/getlayer", "GetLayer",

    "/template", "TemplatePage",
    #"/(.+)/(.+)", "EsApp",
    #"/(.+)/", "EsApp",
    "/", "EsApp")

app = web.application(urls, globals(), autoreload=True)
application = app.wsgifunc()
#session = web.session.Session(app, web.session.DiskStore('../logs/mstmp/webpySessions'))


class EsApp:
    def __init__(self):
        self.lang = "en"

    def GET(self):
        #return sys.path
        #return web.ctx
        render = web.template.render(locals.es2globals['base_dir']+'/apps/gui/esapp')
        return render.index()
        #getparam = web.input(lang=self.lang)
        #return render.index(getparam.lang)


class GetLayer:
    def __init__(self):
        self.lang = "en"

    def GET(self):
        #import StringIO
        import mapscript

        #web.header('Content-type', 'image/png')
        #web.header('Content-transfer-encoding', 'binary')
        #buf = StringIO.StringIO()
        #mapscript.msIO_installStdoutToBuffer()
        #map = mapserver.getmap()
        ##map.save to a file fname.png
        ##web.header('Content-Disposition', 'attachment; filename="fname.png"')
        #contents = buf.getvalue()
        #return contents


        projlib = "/usr/share/proj/"
        errorfile = es_constants.apps_dir+"analysis/ms_tmp/ms_errors.log"
        imagepath = es_constants.apps_dir+"analysis/ms_tmp/"
        productfile = '/data/processing/vgt_ndvi/WGS84_Africa_1km/tif/ndv/20130701_vgt_ndvi_ndv_WGS84_Africa_1km.tif'

        #ows = mapscript.OWSRequest()
        #for k, v in web.input():
        #    if k.lower() in ['image', 'coverage']:
        #        continue
        #    ows.setParameter(k, v)

        #ows.setParameter("LAYERS", "image")
        #ows.setParameter("COVERAGE", "image")
        productmap = mapscript.mapObj(es_constants.template_mapfile)
        productmap.setConfigOption("PROJ_LIB", projlib)
        productmap.setConfigOption("MS_ERRORFILE", errorfile)
        productmap.setConfigOption("DEBUG ", 5)

        outputformat = mapscript.outputFormatObj()
        outputformat.extension = 'PNG'
        outputformat.imagemode = mapscript.MS_IMAGEMODE_INT16
        outputformat.mimetype = 'image/png'

        productmap.setOutputFormat(outputformat)
        productmap.setProjection("+init=epsg:4326")
        productmap.debug = mapscript.MS_TRUE
        productmap.status = mapscript.MS_ON
        productmap.setSize(736, 782)
        productmap.setExtent(-4863270.2540311385, -7205400.673576976, 9538688.86734863, 8096680.892889029)
        productmap.units = mapscript.MS_DD

        raster = mapscript.layerObj(productmap)
        raster.name = 'vgt_ndvi_ndv_WGS84_Africa_1km'
        raster.type = mapscript.MS_RASTER   # MS_LAYER_RASTER
        raster.status = mapscript.MS_ON     # MS_DEFAULT
        raster.data = productfile
        #raster.setProjection("+init=epsg:4326")
        raster.dump = mapscript.MS_TRUE

        result_map_file = es_constants.apps_dir+'analysis/MAP_result.map'
        if os.path.isfile(result_map_file):
            os.remove(result_map_file)
        productmap.save(result_map_file)
        image = productmap.draw()
        image.save(es_constants.apps_dir+'analysis/20130701_vgt_ndvi_ndv_WGS84_Africa_1km.png')

        #raster.metadata.set("wcs_formats", "GEOTIFF JPEG2000")
        logger.debug("MapServer: Installing stdout to buffer.")
        mapscript.msIO_installStdoutToBuffer()
        #contents = productmap.OWSDispatch(ows)
        content_type = mapscript.msIO_stripStdoutBufferContentType()
        content = mapscript.msIO_getStdoutBufferBytes()
        print content
        #web.header = "Content-Type","%s; charset=utf-8"%content_type
        web.header('Content-type', 'image/jpeg')
        #web.header('Content-transfer-encoding', 'binary')
        return content


class DataSets:
    def __init__(self):
        self.lang = "en"

    def GET(self):
        # return web.ctx
        db_products = querydb.get_products(echo=False)

        if db_products.__len__() > 0:
            products_dict_all = []
            # loop the products list
            for row in db_products:
                prod_dict = functions.row2dict(row)
                productcode = prod_dict['productcode']
                version = prod_dict['version']
                p = Product(product_code=productcode, version=version)

                # does the product have mapsets AND subproducts?
                all_prod_mapsets = p.mapsets
                all_prod_subproducts = p.subproducts
                if all_prod_mapsets.__len__() > 0 and all_prod_subproducts.__len__() > 0:
                    prod_dict['productmapsets'] = []
                    for mapset in all_prod_mapsets:
                        mapset_info = querydb.get_mapset(mapsetcode=mapset, allrecs=False, echo=False)
                        mapset_dict = functions.row2dict(mapset_info)
                        mapset_dict['mapsetdatasets'] = []
                        all_mapset_datasets = p.get_subproducts(mapset=mapset)
                        for subproductcode in all_mapset_datasets:
                            dataset_info = querydb.get_subproduct(productcode=productcode,
                                                                  version=version,
                                                                  subproductcode=subproductcode,
                                                                  echo=False)
                            dataset_dict = functions.row2dict(dataset_info)
                            #if dataset_dict['product_type'] != 'Derived':
                            #if dataset_dict['productcode'] != 'vgt_fapar':
                            dataset = p.get_dataset(mapset=mapset, sub_product_code=subproductcode)
                            completeness = dataset.get_dataset_normalized_info()
                            dataset_dict['datasetcompleteness'] = completeness

                            mapset_dict['mapsetdatasets'].append(dataset_dict)
                        prod_dict['productmapsets'].append(mapset_dict)
                products_dict_all.append(prod_dict)

            prod_json = json.dumps(products_dict_all,
                                   ensure_ascii=False,
                                   sort_keys=True,
                                   indent=4,
                                   separators=(', ', ': '))

            datamanagement_json = '{"success":true, "total":'\
                                  + str(db_products.__len__())\
                                  + ',"products":'+prod_json+'}'
        else:
            datamanagement_json = '{"success":false, "error":"No data sets defined!"}'

        return datamanagement_json


class CheckStatusAllServices:
    def __init__(self):
        self.lang = "en"

    def POST(self):
        #return web.ctx
        dry_run = True

        ingest = "false"
        pid_file = es_constants.ingest_pid_filename
        ingest_daemon = acquisition.IngestDaemon(pid_file, dry_run=dry_run)
        if ingest_daemon.status():
            ingest = "true"

        internet = "false"
        pid_file = es_constants.get_internet_pid_filename
        getinternet_daemon = acquisition.GetInternetDaemon(pid_file, dry_run=dry_run)
        if getinternet_daemon.status():
            internet = "true"

        eumetcast = "false"
        pid_file = es_constants.get_eumetcast_pid_filename
        geteumetcast_daemon = acquisition.GetEumetcastDaemon(pid_file, dry_run=dry_run)
        if geteumetcast_daemon.status():
            eumetcast = "true"

        processing = "false"

        servicesstatus_json = '{"success": true, "eumetcast": ' + eumetcast + \
                              ', "internet": ' + internet + \
                              ', "ingest": ' + ingest + \
                              ', "processing": ' + processing + '}'

        return servicesstatus_json


class ExecuteServiceTask:
    def __init__(self):
        self.lang = "en"

    def POST(self):
        #return web.ctx
        getparams = web.input()
        if getparams.task == 'runinternet':
            # if internet_on() run getinternet service
            print 'run internet'
        if getparams.task == 'stopinternet':
            # if internet_on() run getinternet service
            print 'stop internet'
        if getparams.task == 'restartinternet':
            # if internet_on() run getinternet service
            print 'restart internet'

        servicesstatus_json = '{"success": true, "task": "' + getparams.task + '"}'
        return servicesstatus_json


class UpdateProduct:
    def __init__(self):
        self.lang = "en"
        self.crud_db = crud.CrudDB(schema=es_constants.dbglobals['schema_products'])

    def PUT(self):
        #return web.ctx
        getparams = json.loads(web.data())
        productinfo = {'productcode': getparams['products']['productcode'],
                       'subproductcode': getparams['products']['subproductcode'],
                       'version': getparams['products']['version'],
                       'product_type': getparams['products']['product_type'],
                       'defined_by': getparams['products']['defined_by'],
                       'activated': getparams['products']['activated']}
        #print productinfo
        if self.crud_db.update('product', productinfo):
            updatestatus = '{"success":true, "message":"Product updated!"}'
        else:
            updatestatus = '{"success":false, "message":"An error occured while updating the product!"}'

        return updatestatus


class UpdateDataAcquisition:
    def __init__(self):
        self.lang = "en"
        self.crud_db = crud.CrudDB(schema=es_constants.dbglobals['schema_products'])

    def PUT(self):
        #return web.ctx
        getparams = json.loads(web.data())
        dataacquisitioninfo = {'productcode': getparams['dataacquisitions']['productcode'],
                               'subproductcode': getparams['dataacquisitions']['subproductcode'],
                               'version': getparams['dataacquisitions']['version'],
                               'data_source_id': getparams['dataacquisitions']['data_source_id'],
                               'defined_by': getparams['dataacquisitions']['defined_by'],
                               'activated': getparams['dataacquisitions']['activated']}
        #print dataacquisitioninfo
        if self.crud_db.update('product_acquisition_data_source', dataacquisitioninfo):
            updatestatus = '{"success":true, "message":"Data source updated!"}'
        else:
            updatestatus = '{"success":false, "message":"An error occured while updating the data source!"}'

        return updatestatus


class UpdateIngestion:
    def __init__(self):
        self.lang = "en"
        self.crud_db = crud.CrudDB(schema=es_constants.dbglobals['schema_products'])

    def PUT(self):
        #return web.ctx
        getparams = json.loads(web.data())
        ingestioninfo = {'productcode': getparams['ingestions']['productcode'],
                         'subproductcode': getparams['ingestions']['subproductcode'],
                         'version': getparams['ingestions']['version'],
                         'mapsetcode': getparams['ingestions']['mapsetcode'],
                         'defined_by': getparams['ingestions']['defined_by'],
                         'activated': getparams['ingestions']['activated']}
        #print ingestioninfo
        if self.crud_db.update('ingestion', ingestioninfo):
            updatestatus = '{"success":true, "message":"Ingestion updated!"}'
        else:
            updatestatus = '{"success":false, "message":"An error occured while updating the Ingestion!"}'

        return updatestatus


class Ingestion:
    def __init__(self):
        self.lang = "en"

    def GET(self):
        #return web.ctx
        ingestions = querydb.get_ingestions(echo=False)

        if ingestions.__len__() > 0:
            ingest_dict_all = []
            for row in ingestions:
                kwargs = {'product_code': row.productcode,
                          'sub_product_code': row.subproductcode,
                          'version': row.version,
                          'mapset': row.mapsetcode}
                #kwargs.update({'to_date': datetime.date(2013, 12, 31)})
                dataset = Dataset(**kwargs)
                completeness = dataset.get_dataset_normalized_info()
                ingest_dict = functions.row2dict(row)
                ingest_dict['completeness'] = completeness
                ingest_dict_all.append(ingest_dict)

            #ingestions_json = tojson(ingestions)
            ingestions_json = json.dumps(ingest_dict_all,
                                         ensure_ascii=False,
                                         sort_keys=True,
                                         indent=4,
                                         separators=(', ', ': '))
            ingestions_json = '{"success":true, "total":'+str(ingestions.__len__())+',"ingestions":'+ingestions_json+'}'
        else:
            ingestions_json = '{"success":false, "error":"No ingestions defined!"}'

        return ingestions_json


class DataAcquisition:
    def __init__(self):
        self.lang = "en"

    def GET(self):
        #return web.ctx

        dataacquisitions = querydb.get_dataacquisitions(echo=False)

        if dataacquisitions.__len__() > 0:
            #dataacquisitions_json = tojson(dataacquisitions)

            acq_dict_all = []
            for row in dataacquisitions:
                acq_dict = functions.row2dict(row)
                # Retrieve datetime of latest acquired file and lastest datetime
                # the acquisition was active of a specific eumetcast id
                acq_dates = get_eumetcast.get_eumetcast_info(row.data_source_id)
                if acq_dates:
                    for key in acq_dates.keys():
                        #acq_info += '"%s": "%s", ' % (key, acq_dates[key])
                        if isinstance(acq_dates[key], datetime.date):
                            datetostring = acq_dates[key].strftime("%y-%m-%d %H:%M")
                            acq_dict[key] = datetostring
                        else:
                            acq_dict[key] = acq_dates[key]
                else:
                    acq_dict['time_latest_copy'] = datetime.datetime.now().strftime("%y-%m-%d %H:%M")
                    acq_dict['time_latest_exec'] = datetime.datetime.now().strftime("%y-%m-%d %H:%M")
                    acq_dict['lenght_proc_list'] = datetime.datetime.now().strftime("%y-%m-%d %H:%M")

                acq_dict_all.append(acq_dict)
                acq_json = json.dumps(acq_dict_all,
                                      ensure_ascii=False,
                                      sort_keys=True,
                                      indent=4,
                                      separators=(', ', ': '))
                dataacquisitions_json = '{"success":true, "total":'\
                                        + str(dataacquisitions.__len__())\
                                        + ',"dataacquisitions":'+acq_json+'}'
        else:
            dataacquisitions_json = '{"success":false, "error":"No data acquisitions defined!"}'

        return dataacquisitions_json


class ProductAcquisition:
    def __init__(self):
        self.lang = "en"

    def GET(self, params):
        #return web.ctx
        getparams = web.input()
        products = querydb.get_products(echo=False, activated=getparams.activated)
        products_json = functions.tojson(products)
        products_json = '{"success":true, "total":'+str(products.__len__())+',"products":['+products_json+']}'
        return products_json


class TemplatePage:
    def __init__(self):
        self.render = web.template.render(locals.es2globals['base_dir']+'/templates/')

    def GET(self):
        getInput=web.input(name="World")
        return self.render.mytemplate("mytitle", getInput.name)

if __name__ == "__main__":
    app.run()